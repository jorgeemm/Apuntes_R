theme(plot.title=TemaTítulo) +
theme(axis.title=element_text(face="bold", color="blue", size=rel(1.5)))+
geom_text(aes(label=paste0(Total,"","","(",Porcentaje, "%",")")), #la diferencia entre paste y paste0 es que no se dejan espacios entre el número y el % //las "" nada dentro son espacios
vjust=-0.2,color="black",size=4)
ggplot(Tabla, aes(x=Private, y=Total, fill=Private))+
geom_bar(width=0.9, stat="identity", position = position_dodge())+
theme(text=element_text(size=8))+
ggtitle("Distribución de luniversidades \n por tipo de titularidad")+ #\n es para indicar que se salta a la siguiente línea
labs(x="Universidad privada", y="Nº de universidades")+
theme(plot.title=TemaTítulo) +
theme(axis.title=element_text(face="bold", color="blue", size=rel(1.5)))+
geom_text(aes(label=paste0(Total,"","","(",Porcentaje, "%",")")), #la diferencia entre paste y paste0 es que no se dejan espacios entre el número y el % //las "" nada dentro son espacios
vjust=-0.3,color="black",size=4)
#En vertical
ggplot(Tabla, aes(x=Private, y=Total, fill=Private))+
geom_bar(width=0.9, stat="identity", position = position_dodge())+
theme(text=element_text(size=8))+
ggtitle("Distribución de luniversidades \n por tipo de titularidad")+ #\n es para indicar que se salta a la siguiente línea
labs(x="Universidad privada", y="Nº de universidades")+
theme(plot.title=TemaTítulo) +
theme(axis.title=element_text(face="bold", color="blue", size=rel(1.5)))+
geom_text(aes(label=paste0(Total,"","","(",Porcentaje, "%",")")), #la diferencia entre paste y paste0 es que no se dejan espacios entre el número y el % //las "" nada dentro son espacios
vjust=-0.3,color="black",size=4) +
facet_grid(-"Diagrama de barras para el tipo de universidad")+
theme(legend.position="")+ #Para borrar la leyenda
coord_flip() #Para poner las barras en vertical
#En vertical
ggplot(Tabla, aes(x=Private, y=Total, fill=Private))+
geom_bar(width=0.9, stat="identity", position = position_dodge())+
theme(text=element_text(size=8))+
ggtitle("Distribución de luniversidades \n por tipo de titularidad")+ #\n es para indicar que se salta a la siguiente línea
labs(x="Universidad privada", y="Nº de universidades")+
theme(plot.title=TemaTítulo) +
theme(axis.title=element_text(face="bold", color="blue", size=rel(1.5)))+
geom_text(aes(label=paste0(Total,"","","(",Porcentaje, "%",")")), #la diferencia entre paste y paste0 es que no se dejan espacios entre el número y el % //las "" nada dentro son espacios
vjust=-0.3,color="black",size=4) +
facet_grid(~"Diagrama de barras para el tipo de universidad")+
theme(legend.position="")+ #Para borrar la leyenda
coord_flip() #Para poner las barras en vertical
####Histogramas####
ggpolt(College)+ geom_hitogram(aes(x=Outstate))
####Histogramas####
ggplot(College)+ geom_hitogram(aes(x=Outstate))
####Histogramas####
ggplot(College)+ geom_histogram(aes(x=Outstate))
#Incluir una línea con el valor de la media
ggplot(College)+ geom_histogram(aes(x=Outstate))+
geom_vline(aes(xintercept=mean(Outstate)), color="stateblue", lwd=2, lty=3)+
geom_text(geom="text",label="matríclura media", x=mean(Outstate)+3000, y=50, col="stateblue")
#Incluir una línea con el valor de la media
ggplot(College)+ geom_histogram(aes(x=Outstate))+
geom_vline(aes(xintercept=mean(Outstate)), color="stateblue", lwd=2, lty=3)+
geom_text(geom="text",label="matríclura media", x=mean(College$Outstate)+3000, y=50, col="stateblue")
#Incluir una línea con el valor de la media
ggplot(College)+ geom_histogram(aes(x=Outstate))+
geom_vline(aes(xintercept=mean(Outstate)), color="stateblue", lwd=2, lty=3)
#Incluir una línea con el valor de la media
ggplot(College)+ geom_histogram(aes(x=Outstate))+
geom_vline(aes(xintercept=mean(Outstate)), color="slateblue", lwd=2, lty=3)+
geom_text(geom="text",label="matríclura media", x=mean(College$Outstate)+3000, y=50, col="slateblue")
#Modificar algunas opciones del histograma inicial
ggplot(data=College)+
geom_histogram(aes(x=Outsate), fill="lightblue", col="white")+
labs(X="Coste de matrícula", y="Nº de universidades")
#Modificar algunas opciones del histograma inicial
ggplot(data=College)+
geom_histogram(aes(x=Outstate), fill="lightblue", col="white")+
labs(X="Coste de matrícula", y="Nº de universidades")
ggplot(data=College)+
geom_histogram(aes(x=Outstate), fill="lightblue", col="white")+
labs(X="Coste de matrícula", y="Nº de universidades", title="Distribución")+
theme(plot.title=element_text(face="bold", color="wheat",size=15,hjust=.5,vjust=1))+
theme(axis.text.x=elemet_text(color="violet",size=10),
axis.text.y=element_text(color="violet", size=10))
ggplot(data=College)+
geom_histogram(aes(x=Outstate), fill="lightblue", col="white")+
labs(X="Coste de matrícula", y="Nº de universidades", title="Distribución")+
theme(plot.title=element_text(face="bold", color="wheat",size=15,hjust=.5,vjust=1))+
theme(axis.text.x=element_text(color="violet",size=10),
axis.text.y=element_text(color="violet", size=10))
ggplot(College)+
geom_histogram(aes(x=Outstate,fill=Private),col="white",position="fill")+
labs(x="Coste", y="NºUniversidades")
ggplot(College)+
geom_histogram(aes(x=Outstate,fill=Private, col=Private),alpha=0.5)+
labs(x="Coste", y="NºUniversidades")
ggplot(College)+
geom_histogram(aes(x=Outstate,fill=Private),col="white",position="fill")+
labs(x="Coste", y="NºUniversidades")
#Separar los histogramas
ggplot(data=College)+
geom_histogram(aes(x=Outstate), fill="lightblue", col="white")+
labs(X="Coste de matrícula", y="Nº de universidades", title="Distribución")+
facet_wrap(~Private)
#Cambair la orientación
ggplot(data=College)+
geom_histogram(aes(x=Outstate), fill="lightblue", col="white")+
labs(X="Coste de matrícula", y="Nº de universidades", title="Distribución")+
facet_wrap(~Private,nrow=2)
#Diagramas de densidad
ggplot(dCollege, aes(x=Otstate, fill=Private))+
geom_density(alpha=.7)
#Diagramas de densidad
ggplot(College, aes(x=Otstate, fill=Private))+
geom_density(alpha=.7)
#Diagramas de densidad
ggplot(College, aes(x=Outstate, fill=Private))+
geom_density(alpha=.7)
#Datos disgregados
ggplot(College)+
geom_density(aes(X=Outstate, fill=Private))+
facet_grid(Private~.)+
xlab("Coste de matrícula")+
ylab("")+
ggtilte("distribución del coste de matrílcula")+
theme_minimal()
#Datos disgregados
ggplot(College)+
geom_density(aes(x=Outstate, fill=Private))+
facet_grid(Private~.)+
xlab("Coste de matrícula")+
ylab("")+
ggtilte("distribución del coste de matrílcula")+
theme_minimal()
#Datos disgregados
ggplot(College)+
geom_density(aes(x=Outstate, fill=Private))+
facet_grid(Private~.)+
xlab("Coste de matrícula")+
ylab("")+
ggtitle("distribución del coste de matrílcula")+
theme_minimal()
ggplot(College)+geom_boxplot(aes(x=Private, y=Outsate, fill=Private))+
coord_flip()+
geom_jitter(aes(x=Private, y=Outsate), size=2,slpha=.2,withd=0.1)
ggplot(College)+geom_boxplot(aes(x=Private, y=Outsate, fill=Private))+
coord_flip()+
geom_jitter(aes(x=Private, y=Outsate), size=2,alpha=.2,width=0.1)
ggplot(College)+geom_boxplot(aes(x=Private, y=Outstate, fill=Private))+
coord_flip()+
geom_jitter(aes(x=Private, y=Outsate), size=2,alpha=.2,width=0.1)
ggplot(College)+geom_boxplot(aes(x=Private, y=Outstate, fill=Private))+
coord_flip()+
geom_jitter(aes(x=Private, y=Outstate), size=2,alpha=.2,width=0.1)
#Incorporar la media
ggplot(College, aes(x=Private,y=Outstate))+
geom_boxplot(aes(fill=Private))+
theme(legend.position = "none")+
scale_fill_brewer(palette="Blues")+
coor_flip()+
stat_summary(fun=mean,geom="point",shape=18,size=3,col="violet")
#Incorporar la media
ggplot(College, aes(x=Private,y=Outstate))+
geom_boxplot(aes(fill=Private))+
theme(legend.position = "none")+
scale_fill_brewer(palette="Blues")+
coord_flip()+
stat_summary(fun=mean,geom="point",shape=18,size=3,col="violet")
#Identificación de los atípicos (en la consola)
College %>%
grouop_by(Private) %>%
summarize(atípicos=boxplot.stats(Outstate)Sout)
#Identificación de los atípicos (en la consola)
College %>%
grouop_by(Private) %>%
summarize(atípicos=boxplot.stats(Outstate)$out)
#Identificación de los atípicos (en la consola)
College %>%
group_by(Private) %>%
summarize(atípicos=boxplot.stats(Outstate)$out)
install.packages("ggcorrplot")
####Matriz de correlaciones entre diferentes variables cuantitativas####
library(ggcorrplot)
####Matriz de correlaciones entre diferentes variables cuantitativas####
library(ggcorplot)
####Matriz de correlaciones entre diferentes variables cuantitativas####
library(ggcorrplot)
College3<-select(College,~Private) #Eliminamos la variable PRivate, que es un factor
corr<-round(cor(College3),1)
College3<-select(College,-Private) #Eliminamos la variable PRivate, que es un factor
corr<-round(cor(College3),1)
ggcorrplot(corr)+
ggtilte("correlaciones")
ggcorrplot(corr)+
ggtitle("correlaciones")
ggcorrplot(corr)+
ggtitle("correlaciones")+
theme(axix.text.x=element_text(color="blue",size=5),
axix.text.y=element_text(color="blue",size=5))
ggcorrplot(corr)+
ggtitle("correlaciones")+
theme(axis.text.x=element_text(color="blue",size=5),
axis.text.y=element_text(color="blue",size=5))
####Análisis bivariados en una misma ventana####
library(cowplot)
install.packages("cowplot")
####Análisis bivariados en una misma ventana####
library(cowplot) #solo para ggplot
#Diagrama de barras vertical y horizontal
ggplot(College2,aes(Private,fill=Private))+
geom_bar(width=.5,col="grey")+
labs(x="Universidad Privada", y="Nº Universidades")
ggplot(College2, aes(topUniversity, filltopUniversity))+
geom_bar()+
labs(x="Top University",y="Universidades con mayores Top10")+
coord_flip()
ggplot(College2, aes(topUniversity, filltopUniversity))+
geom_bar(width=.5,col="grey")+
labs(x="Top University",y="Universidades con mayores Top10")+
coord_flip()
ggplot(College2, aes(topUniversity, fill=topUniversity))+
geom_bar(width=.5,col="grey")+
labs(x="Top University",y="Universidades con mayores Top10")+
coord_flip()
plot_grid(Barra1,Barra2,nrow=1,align="h")
#Diagrama de barras vertical y horizontal
Barra1 <- ggplot(College2,aes(Private,fill=Private))+
geom_bar(width=.5,col="grey")+
labs(x="Universidad Privada", y="Nº Universidades")
Barra2<-ggplot(College2, aes(topUniversity, fill=topUniversity))+
geom_bar(width=.5,col="grey")+
labs(x="Top University",y="Universidades con mayores Top10")+
coord_flip()
plot_grid(Barra1,Barra2,nrow=1,align="h")
library(patchwork)
#Tres gráficas en una cuatdrícula 2x2
p1 <- ggplot(College2,aes(Private,fill=Private))+
geom_bar(width=.5,col="grey")+
labs(x="Universidad Privada", y="Nº Universidades")
p2<-ggplot(College2, aes(topUniversity, fill=topUniversity))+
geom_bar(width=.5,col="grey")+
labs(x="Top University",y="Universidades con mayores Top10")+
coord_flip()
p3<-ggplot(College)+
geom_histogram(aes(Outsate, fill=Private, col=Private),alpha(=.5)+
diseño1<-"
12
33"
p1+p2+p3pplot_layout(design=diseño1)
p1+p2+p3+pplot_layout(design=diseño1)
p3<-ggplot(College)+
geom_histogram(aes(Outsate, fill=Private, col=Private),alpha(=.5)+
p3<-ggplot(College)+
geom_histogram(aes(Outsate, fill=Private, col=Private),alpha=.5)+
labs(x="coste", y="Nº Universidaes"))
ggplot(College)+
geom_histogram(aes(Outsate, fill=Private, col=Private),alpha=.5)+
labs(x="coste", y="Nº Universidaes"))
ggplot(College)+
geom_histogram(aes(Outsate, fill=Private, col=Private),alpha=.5)+
labs(x="coste", y="Nº Universidaes")
ggplot(College)+
geom_histogram(aes(Outstate, fill=Private, col=Private),alpha=.5)+
labs(x="coste", y="Nº Universidaes")
p3<-ggplot(College)+
geom_histogram(aes(Outstate, fill=Private, col=Private),alpha=.5)+
labs(x="coste", y="Nº Universidaes")
diseño1<-"
12
33"
p1+p2+p3+pplot_layout(design=diseño1)
p1+p2+p3+plot_layout(design=diseño1)
ggsave(paste("gráfcico_",i,".pdf"),gráfico1, width=14,height=8,device=pdf)
#Guardar estos resultados en un pdf
i<-1
diseño1<-"
12
33"
p1+p2+p3+plot_layout(design=diseño1)
ggsave(paste("gráfcico_",i,".pdf"),gráfico1, width=14,height=8,device=pdf)
grafico1<-p1+p2+p3+plot_layout(design=diseño1)
ggsave(paste("gráfcico_",i,".pdf"),grafico1, width=14,height=8,device=pdf)
i<-i+1
diseño2<-"
12"
grafico2<-p1+p3+plot_layout(design=diseño2)
ggsave(paste("gráfcico_",i,".pdf"),grafico2, width=14,height=8,device=pdf)
autompg=read.table("http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto.mpg.data")
autompg=read.table("http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data")
view(autompg)
#Añadir nombres a las variables
colnames(autompg)=c("mpg","cyl","disp","hp","wt","acc","year","origin","name")
view(autompg)
#Eliminar errores -> pasar a valores perdidos
aotompg=subset(autompg,autompg$hp!="?")
view(autompg)
autompg=read.table("http://archive.ics.uci.edu/ml/machine-learning-databases/auto-mpg/auto-mpg.data")
#Añadir nombres a las variables
colnames(autompg)=c("mpg","cyl","disp","hp","wt","acc","year","origin","name")
#Eliminar errores -> pasar a valores perdidos
autompg=subset(autompg,autompg$hp!="?")
#Ver el tipo de variables
stra(autompg)
#Ver el tipo de variables
str(autompg)
autompg$hp=as.numeric(autompg$hp)
str(autompg)
install.packages("scatterplot3d")
####Modelo de regresión múltiple####
library(scatterplot3d)
scatterplot3d(autompg$hap, autompg$wt, autompg$mpg, pch=19,col="blue")
scatterplot3d(autompg$hap, autompg$wt, autompg$mpg, pch=19,color="blue")
scatterplot3d(autompg$hp, autompg$wt, autompg$mpg, pch=19,color="blue")
#Estimación del modelo
mpg_model<.lm(mpg~hp+wt, data=autompg)
#Estimación del modelo
mpg_model<-lm(mpg~hp+wt, data=autompg)
mpgmodel
mpg_model
#Coeficientes del modelo estimado
coef(mpg_model)
summary(mpg_model)
summary(mpg_model)$coef
coefint(mpg_model,level=0.99)
confint(mpg_model,level=0.99)
mpg_model<-lm(mpg~hp, data=autompg)
ggplot(autompg, aes(hp,mpg))+geom_point()
B0_mpg<-coef(mpg_model)[1]
B1_mpg<-coef(mpg_model)[2]
ggplot(autompg, aes(hp,mpg))+geom_point()+
geom_abline(intercept=B0_mpg, slope=B1_mpg,col="violet",lty=1,ltd=1)
ggplot(autompg, aes(hp,mpg))+geom_point()+
geom_abline(intercept=B0_mpg, slope=B1_mpg,col="violet",lty=1,lwd=1)
#Incorporar variable dummy
#Creamos una nueva variable dummy llamada domestic
autompg$domestic<-as.numeric(autompg$origin==1) #crea la variable dando el valor 1 cuando la variable origin tiene los valores 1
autompg$domestic<-as.factor(autompg$domestic)
ggplot(autompg, aes(hp, mpg, col=comestic))+geom_point(size=2,alpha=I(0.7))
ggplot(autompg, aes(hp, mpg, col=domestic))+geom_point(size=2,alpha=I(0.7))
mpg_hp_dom<-lm(mpg~hp+domestic,data=autompg)
summary(mpg_hp_dom)
#Realmente existen dos rectas de regresión, con la misma pendiente, pero una con un B0 para EEUU y otra para los de fuera
B0_extr<-coef(mpg_hp_dom)[1]
B0_dom<-coef(mpg_hp_dom)[1]+coef(mpg_hp_dom)[3]
B1_extr<-coef(mpg_hp_dom)[2]
B1_dom<-coef(mpg_hp_dom)[2]
gpglot(autompg, aes(hp,mpg,col=domestic))+
geom_point(size=2,alpha=I(0.7))+
geom_abline(intercept=B0_dom,slope=B1_dom,col="turquoise2",lty=1,lwd=1)+
geom_abline(intercept=B0_extr,slope=B1_extr,col="salmon1",lty=1,lwd=1)
ggplot(autompg, aes(hp,mpg,col=domestic))+
geom_point(size=2,alpha=I(0.7))+
geom_abline(intercept=B0_dom,slope=B1_dom,col="turquoise2",lty=1,lwd=1)+
geom_abline(intercept=B0_extr,slope=B1_extr,col="salmon1",lty=1,lwd=1)
####Interacciones####
mpg_hp_int=lm(mpg~hp+domestic+hp:domestic,data=autompg)
summary(mpg_hp_int)
B0_extr<-coef(mpg_hp_int)[1]
B0_dom<-coef(mpg_hp_int)[1]+coef(mpg_hp_int)[3]
B1_extr<-coef(mpg_hp_int)[2]
B1_dom<-coef(mpg_hp_int)[2]+coef(mpg_hp_int)[4]
ggplot(autompg,aes(hp,mpg,col=domestic))+
geom_point(size=2,alpha=I(0.7))+
geom_abline(intercept=B0_dom,slope=B1_dom,col="turquoise2",lty=1,lwd=1)+
geom_abline(intercept=B0_extr,slope=B1_extr,col="salmon1",lty=1,lwd=1)
#Para ver que modelo es mejor se utiliza ANOVA
#Hiotesis nula: el primero
#Hipótesisi alternativa: el segundo
anova(mpg_hp_dom,mpg_hp_int)
install.packages("vcd")
####Regresión logística####
library(ISLR2)
library(vdc)
library(vcd)
library(tidyverse)
names(Default)
summary(Default)
#Análisis exploratorio
ggplot(Default, aes(default,balanc, color=default))+
geom_boxplot()+
geom_jitter(width = .1)+
theme_bw()+
theme(legend.position="null")
#Análisis exploratorio
ggplot(Default, aes(default,balance, color=default))+
geom_boxplot()+
geom_jitter(width = .1)+
theme_bw()+
theme(legend.position="null")
#Análisis exploratorio
ggplot(Default, aes(default,balance, color=default))+
geom_boxplot()+
geom_jitter(width = .1)+
theme_bw()+
theme(legend.position="null")
ggplot(Default, aes(default,income, color=default))+
geom_boxplot()+
geom_jitter(width = .1)+
theme_bw()+
theme(legend.position="null")
ggplot(Default)+
geom_bar(aes(default,student))
ggplot(Default)+
geom_bar(aes(default,fill=student))
#Creación del dataset train y test
ntrain<-nrow(Default)*0.8
ntest<-nrow(Default)*0.2
set.seed(161)
index_train<-sample(1:nrow(Default),size=ntrain)
train<-Default[index_train,]
test<-Default[-index_train]
summary(train)
summary(test)
summary(train)
summary(test)
test<-Default[-index_train,]
summary(train)
summary(test)
#Estimación del modelo
logit_reg<-gml(default~balance+student+income,data=train,famili="binomial")
#Estimación del modelo
logit_reg<-glm(default~balance+student+income,data=train,famili="binomial")
#Estimación del modelo
logit_reg<-glm(default~balance+student+income,data=train,family="binomial")
#Predicciones
predicted_values<-predict(logit_reg,test,type="response") #las predicciones las hace con el 20% que se dejo fuera
predicted_class<-ifelse(predicted_values>0.5,"Yes","No")
performance_data<-data.frame(observed=test$default,predicted=predicted_class) #crear una dataframe con una columna (valores observados) y las predicciones, para poder compararlas
#Observaciones positivas, negativas, predicciones positivas y negativas
positive<-sum(preformance_data$observed=="Yes")
#Observaciones positivas, negativas, predicciones positivas y negativas
positive<-sum(performance_data$observed=="Yes")
negative<-sum(performance_data$observed="No")
negative<-sum(performance_data$observed=="No")
predicted_positive<-sum(performance_data$predicted=="Yes")
predicted_negative<-sum(performance_data$predicted=="No")
total=nrow(performance_data)
data.frame(positive,negative,predicted_positive,predicted_negative)
#Clasificación: tasas absolutas
tp<-sum(performance_data$observed=="Yes" & performance_data$predicted=="Yes")
tn<-sum(performance_data$observed=="No" & performance_data$predicted=="No")
fp<-sum(performance_data$observed=="No" & performance_data$predicted=="Yes")
fn<-sum(performance_data$observed=="Yes" & performance_data$predicted=="No")
data.frame(tp,tn,fp,fn)
#Clasificación: porcentajes
accuracy<-(tp+tn)/total
error_rate<-(fp+fn)/total
sensitivity<-tp/postitive
especificity<-tn/negative
#Clasificación: porcentajes
accuracy<-(tp+tn)/total
error_rate<-(fp+fn)/total
sensitivity<-tp/postive
sensitivity<-tp/positive
especificity<-tn/negative
precision<-tp/predicted_positive
npv<-tn/predicted_negative
data.frame(accuracy,error_rate,sensitivity,especificity,precision,npv)
#Matriz de confusión: para visualizar cómo es el modelo
matriz_confusión<-table(performance_data,
dnn=c("observaciones", "predicciones"))
matriz_confusión
mosaic(matriz_confusión,shade=T,colorize=T,
gp=gpar(fill=matrix(c("green", "red", "red", "green"),2,2)))
#evaluación del modelo
anova(logit_rep,test=Chisq)
##Gráfico de probabilidades, únicamente para una variable
#Modelo de regresión
modelo<-glm(default~balance, data=train, family="binomial")
#Predicciones del modelo con ggplot
Default<-Default %>%
mutate(default2=0) %>%
mutate(default2=if_else(Default$default=="Yes",1,default2))
#comprobacioens
table(Default$default)
table(Default$default2)
#se crea un vextor con nuevos valores interpolados en el rango de observaciones
neuvos_puntos<-seq(from=min(Default$banance),to=max(Defaul$balance), by=100)
#Predicción de los nuevos puntos según el modelo
#Si se indica se.fit=TRUE se debuelve el error estándar de cada predicción
#Junto con el valroe de la predicción (fit)
predicciones<-predict(modelo,dara.frame(balance=nuevos_puntos),se.fit=TRUE)
#Mediante la función logit se transfroman los log_ODDs a probabilidades
predicciones_logit<.exp(predicciones$fit)/(1+exp(predicciones$fit))
#se crea un vextor con nuevos valores interpolados en el rango de observaciones
neuvos_puntos<-seq(from=min(Default$banance),to=max(Defaul$balance), by=100)
#se crea un vextor con nuevos valores interpolados en el rango de observaciones
neuvos_puntos<-seq(from=min(Default$balance),to=max(Default$balance), by=100)
#Predicción de los nuevos puntos según el modelo
#Si se indica se.fit=TRUE se debuelve el error estándar de cada predicción
#Junto con el valroe de la predicción (fit)
predicciones<-predict(modelo,data.frame(balance=nuevos_puntos),se.fit=TRUE)
save.image("C:/Users/Usuario/OneDrive - Universidad Carlos III de Madrid/Escritorio/Curso R/sesión3.RData")
#se crea un vextor con nuevos valores interpolados en el rango de observaciones
neuvos_puntos<-seq(from=min(Default$balance),to=max(Default$balance), by=100)
#se crea un vextor con nuevos valores interpolados en el rango de observaciones
nuevos_puntos<-seq(from=min(Default$balance),to=max(Default$balance), by=100)
#Predicción de los nuevos puntos según el modelo
#Si se indica se.fit=TRUE se debuelve el error estándar de cada predicción
#Junto con el valroe de la predicción (fit)
predicciones<-predict(modelo,data.frame(balance=nuevos_puntos),se.fit=TRUE)
#Mediante la función logit se transfroman los log_ODDs a probabilidades
predicciones_logit<.exp(predicciones$fit)/(1+exp(predicciones$fit))
#Predicciones del modelo con ggplot
Default<-Default %>%
mutate(default2=0) %>%
mutate(default2=if_else(Default$default=="Yes",1,default2))
#comprobacioens
table(Default$default)
table(Default$default2)
#se crea un vextor con nuevos valores interpolados en el rango de observaciones
nuevos_puntos<-seq(from=min(Default$balance),to=max(Default$balance), by=100)
#Predicción de los nuevos puntos según el modelo
#Si se indica se.fit=TRUE se debuelve el error estándar de cada predicción
#Junto con el valroe de la predicción (fit)
predicciones<-predict(modelo,data.frame(balance=nuevos_puntos),se.fit=TRUE)
#Mediante la función logit se transfroman los log_ODDs a probabilidades
predicciones_logit<.exp(predicciones$fit)/(1+exp(predicciones$fit))
#Mediante la función logit se transfroman los log_ODDs a probabilidades
predicciones_logit<-exp(predicciones$fit)/(1+exp(predicciones$fit))
#Se calcula el límite inferior y suprerior del IC adel 95% sustrayendo e incrementamos el logODDs de cada predicción. Una vez calculados se transforman las probabilidades con la función logit
limite_inferior<-predicciones$fin-1.96*predicciones&se.fit
